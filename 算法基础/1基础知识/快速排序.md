# 快速排序

### 算法
#### (快速排序)  `均摊时间：O(nlogn) & 空间：O(logn) `

* 在数组选一个数v(选中间的)，把数组左边变成`<=v`，右边变成`>=v`,使用分治的思想，分别对**左边**和**右边**进行快速排序

*注意：partition返回的是j，而不是i。*

**解释：** 
`partition` 返回j的原因：
`partition`假如以中点向下取整(l + r >> 1), 只剩下两个数的时候(如 `1 2`) 就会以左边的`1`为基准值`x`，`i` 和 `j` 最后会cross over，因为是do while循环， **i会到2的位置， j会到1的位置**。 这样左边(l, j)是小于等于1， 右边(i, r)是大于等于1.这样不会死循环。**若返回i就会发生划分的左边死循环，一直是(1, 2)划分，无限递归下去**。

若要`返回i`， 跟二分很像，则需要以中点向上取整(`l + r + 1 >> 1`)。 同理，还是以数组剩下两个元素（1， 2）为例， 基准值x取2. 当i, j cross over之后， 左边小于等于2为(`l, i - 1`), 右边大于等于2为(`i， r`)。

```c++
int n;
int a[N];

int partition(int l, int r) {
    int x = a[l + r + 1 >> 1];
    int i = l - 1, j = r + 1;
    while (i < j) {
        do ++i; while (a[i] < x);
        do --j; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    return i;
}

void quick_sort(int l, int r) {
    if (l >= r) return;
    int p = partition(l, r);
    quick_sort(l, p - 1);
    quick_sort(p, r);
}

// 调用
quick_sort(0, n - 1);
```

